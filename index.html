<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Quantum OS™ — Next-Generation AI Operating System</title>
  <meta name="description" content="Quantum OS™ is a next-generation AI operating system architecture for autonomous agent ecosystems. Patent-pending. Available for strategic partnership and licensing." />
  <meta property="og:title" content="Quantum OS™ — Next-Generation AI Operating System" />
  <meta property="og:description" content="Patent-pending AI OS architecture (Quantum Core + Rings) enabling scalable agent orchestration and self-evolving systems. Contact Jim Saenz for partnership." />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="/og-image.jpg" />
  <meta name="theme-color" content="#0b0b0c" />
  <style>
    :root{
      --bg:#0b0b0c; --panel:#111214; --ink:#e8e7e4; --muted:#b9b8b3; --accent:#f15b2a; --ring:#e06f47;
      --edge: #232428;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;color:var(--ink);background:radial-gradient(1200px 800px at 80% 10%,#141517 0%,#0b0b0c 60%);} 
    a{color:var(--ink)}
    .wrap{max-width:1100px;margin:0 auto;padding:28px}
    .nav{display:flex;align-items:center;justify-content:space-between;gap:16px}
    .brand{display:flex;align-items:center;gap:12px}
    .logo{width:32px;height:32px;border-radius:50%;background:conic-gradient(from 0deg,var(--ring),#b9461a,var(--accent),#ff9a73);box-shadow:0 0 0 3px #1c1c1e inset, 0 0 24px rgba(241,91,42,.35)}
    .tag{font-size:12px;color:var(--muted)}
    .cta{appearance:none;border:none;background:var(--accent);color:#111;padding:12px 18px;border-radius:12px;font-weight:700;cursor:pointer;box-shadow:0 6px 20px rgba(241,91,42,.25);transition:transform .15s ease,opacity .2s}
    .cta:hover{transform:translateY(-1px);opacity:.95}
    .hero{display:grid;grid-template-columns:1.2fr .8fr;gap:28px;align-items:center;margin-top:24px}
    .badge{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;background:#15161a;color:var(--muted);border:1px solid var(--edge);font-size:12px}
    h1{font-size:clamp(34px,6vw,64px);letter-spacing:.5px;margin:.2em 0 .15em}
    .sub{font-size:clamp(16px,2.2vw,22px);color:#cfcfcb;opacity:.95}
    .rings{width:min(420px,90%);aspect-ratio:1;border-radius:50%;margin:18px auto;background:radial-gradient(circle at 50% 50%,rgba(241,91,42,.2),transparent 55%), #0e0f11;display:grid;place-items:center;border:1px solid var(--edge);box-shadow:0 0 80px rgba(241,91,42,.12) inset; position: relative;}
    .rings::before,.rings::after{content:"";position:absolute;border-radius:50%;}
    .ring{position:relative;width:78%;aspect-ratio:1;border:2px solid var(--ring);border-radius:50%;display:grid;place-items:center}
    .ring.small{width:46%}
    .ring.tiny{width:22%}
    .core{position:absolute;width:10px;height:10px;border-radius:50%;background:var(--accent);box-shadow:0 0 18px rgba(241,91,42,.8)}
    .label{position:absolute;top:-24px;color:var(--muted);font-size:12px}
    .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:24px;margin-top:36px}
    .card{background:linear-gradient(180deg,#121317,#0c0d0f);border:1px solid #1e2024;border-radius:16px;padding:22px}
    .card h3{margin:0 0 10px;font-size:18px}
    ul{margin:10px 0 0 0;padding-left:18px;color:#d8d7d2}
    li{margin:8px 0;color:#d6d5d0}
    .status{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:16px;margin-top:22px}
    .pill{background:#15161a;border:1px solid var(--edge);border-radius:12px;padding:14px;font-size:14px;color:#d8d7d2}
    .footer{display:flex;flex-wrap:wrap;gap:16px;align-items:center;justify-content:space-between;margin:36px 0 14px;color:#d8d7d2}
    .links{display:flex;gap:14px;align-items:center}
    @media (max-width:900px){
      .hero{grid-template-columns:1fr}
      .grid{grid-template-columns:1fr}
      .status{grid-template-columns:1fr}
      .footer{flex-direction:column;align-items:flex-start}
    }

    /* --- Simulation container styles --- */
    .sim-shell{
      position:relative; width:100%; height:600px; overflow:hidden;
      border:1px solid var(--edge); border-radius:12px; background:#05060a;
    }
    .sim-fallback{
      position:absolute; inset:0; display:grid; place-items:center; color:var(--muted);
    }
    .sim-controls{
      display:flex; justify-content:space-between; align-items:center; gap:12px; margin-top:12px; color:var(--muted); font-size:14px;
    }
    .btn-ghost{
      display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:10px;
      border:1px solid var(--edge); background:rgba(255,255,255,.02); color:var(--ink); text-decoration:none; cursor:pointer;
    }
  </style>
</head>
<body>
  <header class="wrap nav">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <strong>Quantum OS™</strong><div class="tag">Patent-pending AI Operating System</div>
      </div>
    </div>
    <a class="cta" href="mailto:jimsaenz72@gmail.com?subject=Quantum%20OS%20Partnership%20Inquiry&body=Hi%20Jim,%20let%E2%80%99s%20schedule%20an%20NDA%20discussion.">Request Partnership Call</a>
  </header>
  
  <main class="wrap">
    <section class="hero">
      <div>
        <span class="badge">Patent Pending • USPTO App. #63/861,053 • Filed Aug 10, 2025</span>
        <h1>Next-Generation AI Operating System</h1>
        <p class="sub">A Quantum Core + Rings architecture for autonomous agent ecosystems: self-building systems, scalable orchestration, and long-horizon reasoning.</p>
      </div>
      <div style="position:relative;display:grid;place-items:center">
        <div class="rings">
          <div class="ring"><span class="label">RING 1</span>
            <div class="ring small"><span class="label">RING 2</span>
              <div class="ring tiny"></div>
              <div class="core" title="Quantum Core"></div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Simulation (Upgraded, Holographic) -->
    <section class="card" style="margin-top:24px">
      <h3>Quantum OS Architecture Simulation</h3>

      <!-- Mount point -->
      <div id="quantum-sim" class="sim-shell" aria-label="Quantum OS system visualization">
        <div class="sim-fallback">Loading Quantum Core & Rings…</div>
      </div>

      <div class="sim-controls">
        <span>Tip: hover nodes for labels • click canvas to pause/resume</span>
        <button class="btn-ghost" id="toggleSimBtn" type="button">Toggle Pause</button>
      </div>

      <p style="margin-top:12px;font-size:14px;color:var(--muted);">
        This interactive simulation shows the Quantum Core coordinating counter‑rotating data rings and orbiting nodes (Cipher Mesh, Memory Lattice, Vault Nexus, etc.).
      </p>
    </section>

    <section class="grid">
      <div class="card">
        <h3>Overview</h3>
        <p>Quantum OS™ is a revolutionary AI operating system architecture designed for autonomous agent ecosystems. It enables AI systems to self-build, coordinate, and evolve at scale through a proprietary <em>Quantum Core + Rings</em> framework. This architecture delivers unprecedented adaptability and efficiency in training, deployment, and multi-agent orchestration.</p>
      </div>
      <div class="card">
        <h3>Status</h3>
        <div class="status">
          <div class="pill">Architecture & diagrams complete</div>
          <div class="pill">USPTO Provisional Filed — #63/861,053</div>
          <div class="pill">Open to exclusive / non-exclusive licensing</div>
        </div>
      </div>
    </section>

    <section class="grid">
      <div class="card">
        <h3>Key Advantages</h3>
        <ul>
          <li><strong>Self-Evolving Ecosystem</strong> — Agents can generate, optimize, and deploy new agents without manual intervention.</li>
          <li><strong>Scalable Modular Design</strong> — Quantum Core + Rings scales from edge devices to supercomputers.</li>
          <li><strong>Cross-Domain Capability</strong> — Integrates language, vision, robotics, and IoT.</li>
          <li><strong>Efficiency Boost</strong> — Parallelized agent workflows reduce cost and latency.</li>
        </ul>
      </div>
      <div class="card">
        <h3>Potential Applications</h3>
        <ul>
          <li>Enterprise AI infrastructure & private agent networks</li>
          <li>Autonomous systems (robotics, vehicles, defense)</li>
          <li>Cloud-scale AI services & orchestration</li>
          <li>AI research acceleration & long-term reasoning</li>
        </ul>
      </div>
    </section>

    <section class="card wrap" style="margin-top:24px">
      <h3>Download</h3>
      <p>One-page overview PDF for sharing: <a href="/Quantum_OS_Overview.pdf" download>Quantum_OS_Overview.pdf</a></p>
    </section>
  </main>
  
  <footer class="wrap footer">
    <div>
      © <span id="y"></span> Jim Saenz — Founder & Inventor, Quantum OS™
    </div>
    <div class="links">
      <a href="mailto:jimsaenz72@gmail.com">jimsaenz72@gmail.com</a>
      <span>•</span>
      <a href="tel:+18659689985">(865) 968-9985</a>
    </div>
  </footer>
  
  <script>
    // Footer year
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>

  <!-- Holographic Quantum Simulation (inline, no deps) -->
  <script>
  (function(){
    const container = document.getElementById('quantum-sim');
    if (!container) return;

    // Canvas
    while (container.firstChild) container.removeChild(container.firstChild);
    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    container.appendChild(canvas);
    const ctx = canvas.getContext('2d', { alpha: false });
    const DPR = Math.min(window.devicePixelRatio || 1, 2);

    // Colors / style
    const BG = '#05060a';
    const CORE_A = '#86e7ff';
    const CORE_B = '#b681ff';
    const RING = '#8fe7ff';
    const ACCENT = '#9be8ff';
    const NODE = '#d9fbff';

    // Size
    let w=0,h=0,cx=0,cy=0,scale=0, lastW=0, lastH=0;
    function resize() {
      const r = container.getBoundingClientRect();
      canvas.width = Math.max(1, (r.width * DPR) | 0);
      canvas.height = Math.max(1, (r.height * DPR) | 0);
      w = canvas.width; h = canvas.height; cx = w/2; cy = h/2; scale = Math.min(w,h);
      lastW = w; lastH = h;
    }
    resize();

    // Utils
    const TAU = Math.PI*2;
    const rand = (a,b)=>a+Math.random()*(b-a);

    // Grid + scanlines
    function drawHolGrid(t){
      // soft clear
      ctx.fillStyle = BG;
      ctx.fillRect(0,0,w,h);

      // radial haze
      const rg = ctx.createRadialGradient(cx, cy, 0, cx, cy, scale*0.7);
      rg.addColorStop(0, '#0b0d13');
      rg.addColorStop(1, BG);
      ctx.fillStyle = rg; ctx.fillRect(0,0,w,h);

      // scanlines (brighter for mobile visibility)
      ctx.globalAlpha = 0.1;
      const step = 8 * DPR;
      const shift = ((t*0.12)|0) % step;
      for (let y = -shift; y < h; y += step) ctx.fillRect(0, y, w, 1);
      ctx.globalAlpha = 1;

      // polar grid
      ctx.strokeStyle = '#7bdcff55';
      ctx.lineWidth = 1 * DPR;
      for (let r = scale*0.12; r <= scale*0.6; r += scale*0.08) {
        ctx.beginPath(); ctx.arc(cx, cy, r*0.5, 0, TAU); ctx.stroke();
      }
      // spokes
      ctx.strokeStyle = '#7bdcff40';
      const spokes = 16;
      for (let i=0;i<spokes;i++){
        const a = (i/spokes)*TAU + t*0.00025;
        ctx.beginPath(); ctx.moveTo(cx, cy);
        ctx.lineTo(cx + Math.cos(a)*scale*0.35, cy + Math.sin(a)*scale*0.35);
        ctx.stroke();
      }
    }

    // Stars
    const starCount = 260;
    let stars = [];
    function seedStars(){
      stars = Array.from({length: starCount}, () => ({
        x: rand(0,w), y: rand(0,h), z: rand(0.2,1), s: rand(0.6,1.8)*DPR, tw: rand(0.6,1.6)
      }));
    }
    seedStars();
    function drawStars(t){
      for (const s of stars){
        const tw = 0.6 + 0.4 * Math.sin((t*0.0012 + s.x*0.01) * s.tw);
        ctx.globalAlpha = 0.55 * s.z * tw;
        ctx.beginPath(); ctx.arc(s.x, s.y, s.s*s.z, 0, TAU);
        ctx.fillStyle = '#b0bed4'; ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    // Rings
    const rings = [
      { r:.18, w:2.4, speed:  0.06, dash: 46 },
      { r:.28, w:3.0, speed: -0.04, dash: 54 },
      { r:.39, w:3.2, speed:  0.03, dash: 64 },
      { r:.51, w:3.4, speed: -0.02, dash: 78 },
    ];
    function glowCircle(x,y,r,color, alpha=1){
      const grad = ctx.createRadialGradient(x,y,0,x,y,r);
      grad.addColorStop(0, color);
      grad.addColorStop(0.35, color + 'cc');
      grad.addColorStop(1, '#0000');
      ctx.globalAlpha = alpha;
      ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();
      ctx.globalAlpha = 1;
    }
    function drawRings(t){
      ctx.lineCap = 'round';
      for (const def of rings){
        const baseR = def.r * scale * 0.5;
        const dash = def.dash * DPR, gap = dash * 0.78;
        const rot = t * def.speed;

        glowCircle(cx, cy, baseR + 16*DPR, '#5ad2ff44', 1);

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(rot);
        ctx.setLineDash([dash, gap]);
        ctx.lineWidth = def.w * DPR;

        // brighter single color for reliability + slight alpha
        ctx.globalAlpha = 0.95;
        ctx.strokeStyle = RING;
        ctx.beginPath(); ctx.arc(0, 0, baseR, 0, TAU); ctx.stroke();
        ctx.restore();
        ctx.globalAlpha = 1;
      }
    }

    // Core
    function drawCore(t){
      const pulse = 1 + 0.06 * Math.sin(t*0.003);
      const coreR = (scale*0.07) * pulse;
      glowCircle(cx, cy, coreR*3.8, CORE_A, 1);
      glowCircle(cx, cy, coreR*2.6, CORE_B, 0.9);

      ctx.beginPath(); ctx.arc(cx, cy, coreR, 0, TAU);
      const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreR);
      g.addColorStop(0, '#ffffff');
      g.addColorStop(0.55, CORE_A);
      g.addColorStop(1, CORE_B);
      ctx.fillStyle = g; ctx.fill();

      // crosshair (brighter)
      ctx.globalAlpha = 0.5; ctx.strokeStyle = ACCENT; ctx.lineWidth = 1.5*DPR;
      ctx.beginPath(); ctx.moveTo(cx-coreR*2.2, cy); ctx.lineTo(cx+coreR*2.2, cy);
      ctx.moveTo(cx, cy-coreR*2.2); ctx.lineTo(cx, cy+coreR*2.2); ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Nodes
    const labels = ['Quantum Core','Memory Lattice','Cipher Mesh','Zeo Kernel','PulseChain','AuraThread','Vault Nexus','Signal Gate'];
    const nodes = Array.from({length: 8}, (_,i)=>({
      baseR: 0.20 + i*0.055 + rand(-0.01,0.01),
      size: (i===0? 6.0 : rand(3.2,4.8)) * DPR,   // bigger for mobile visibility
      theta: rand(0, TAU),
      speed: (i%2===0? 1 : -1) * rand(0.0026, 0.006),
      label: labels[i % labels.length],
      id: i
    }));
    let paused = false, hoverIndex = null;

    function drawNodes(){
      nodes.forEach((n, i) => {
        if (!paused) n.theta += n.speed;
        const r = n.baseR * scale * 0.5;
        const x = cx + Math.cos(n.theta) * r;
        const y = cy + Math.sin(n.theta) * r;

        glowCircle(x, y, n.size*6, (i===hoverIndex ? '#d9fbffff' : '#d9fbff88'), 1);

        // body
        ctx.beginPath(); ctx.arc(x, y, n.size*(i===hoverIndex ? 1.45 : 1), 0, TAU);
        const g = ctx.createRadialGradient(x, y, 0, x, y, n.size*1.4);
        g.addColorStop(0, '#ffffff'); g.addColorStop(1, NODE);
        ctx.fillStyle = g; ctx.fill();

        // outline to pop
        ctx.strokeStyle = '#ffffffaa'; ctx.lineWidth = 0.8*DPR; ctx.stroke();

        // link
        ctx.globalAlpha = 0.35; ctx.strokeStyle = ACCENT; ctx.lineWidth = 1*DPR;
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(x, y); ctx.stroke();
        ctx.globalAlpha = 1;

        if (i === hoverIndex){
          const label = n.label;
          ctx.font = `${12*DPR}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
          const pad = 6*DPR, textW = ctx.measureText(label).width;
          const bx = x + 10*DPR, by = y - 10*DPR, bw = textW + pad*2, bh = 22*DPR + pad*2, rx = 6*DPR;

          ctx.beginPath();
          const r2 = Math.min(rx, bw/2, bh/2);
          ctx.moveTo(bx - pad + r2, by - 14*DPR - pad);
          ctx.lineTo(bx - pad + bw - r2, by - 14*DPR - pad);
          ctx.quadraticCurveTo(bx - pad + bw, by - 14*DPR - pad, bx - pad + bw, by - 14*DPR - pad + r2);
          ctx.lineTo(bx - pad + bw, by - 14*DPR - pad + bh - r2);
          ctx.quadraticCurveTo(bx - pad + bw, by - 14*DPR - pad + bh, bx - pad + bw - r2, by - 14*DPR - pad + bh);
          ctx.lineTo(bx - pad + r2, by - 14*DPR - pad + bh);
          ctx.quadraticCurveTo(bx - pad, by - 14*DPR - pad + bh, bx - pad, by - 14*DPR - pad + bh - r2);
          ctx.lineTo(bx - pad, by - 14*DPR - pad + r2);
          ctx.quadraticCurveTo(bx - pad, by - 14*DPR - pad, bx - pad + r2, by - 14*DPR - pad);

          ctx.fillStyle = 'rgba(12,16,22,0.92)'; ctx.fill();
          ctx.strokeStyle = ACCENT; ctx.lineWidth = 1*DPR; ctx.globalAlpha = 0.8; ctx.stroke(); ctx.globalAlpha = 1;
          ctx.fillStyle = ACCENT; ctx.fillText(label, bx, by + 6*DPR);
        }
      });
    }

    // Interaction
    canvas.addEventListener('mousemove', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * DPR;
      const my = (e.clientY - rect.top) * DPR;
      let found = null;
      for (let i=0;i<nodes.length;i++){
        const n = nodes[i], r = n.baseR * scale * 0.5;
        const x = cx + Math.cos(n.theta) * r, y = cy + Math.sin(n.theta) * r;
        const hit = n.size*3.5, dx = mx - x, dy = my - y;
        if (dx*dx + dy*dy <= hit*hit) { found = i; break; }
      }
      hoverIndex = found;
    });
    canvas.addEventListener('click', ()=> paused = !paused);
    document.getElementById('toggleSimBtn')?.addEventListener('click', ()=> { paused = !paused; });
    window.addEventListener('resize', ()=>{ resize(); seedStars(); });

    // Animation (with per-frame size check)
    let raf = 0;
    function frame(t){
      // if layout changed (mobile address bar show/hide), re-measure
      if (w !== lastW || h !== lastH) { lastW = w; lastH = h; }
      const r = container.getBoundingClientRect();
      const cw = (r.width * DPR) | 0, ch = (r.height * DPR) | 0;
      if (cw !== w || ch !== h) { resize(); seedStars(); }

      raf = requestAnimationFrame(frame);
      drawHolGrid(t);
      drawStars(t);
      drawRings(t);
      drawCore(t);
      drawNodes();
    }

    // Start
    ctx.fillStyle = BG; ctx.fillRect(0,0,canvas.width,canvas.height);
    frame(performance.now());
  })();
  </script>
</body>
</html>
