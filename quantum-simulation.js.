// /quantum-simulation.js  (place at the same level as index.html or in /public)

(function () {
  function renderQuantumSimulation(container) {
    while (container.firstChild) container.removeChild(container.firstChild);

    const canvas = document.createElement('canvas');
    canvas.style.display = 'block';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d', { alpha: false });
    const DPR = Math.min(window.devicePixelRatio || 1, 2);

    const background = '#07070a';
    const coreColor = '#7bdcff';
    const ringColor = '#2a2f3a';
    const nodeColor = '#c0f1ff';
    const accentColor = '#9aecff';

    let w = 0, h = 0, cx = 0, cy = 0, scale = 0;
    function resize() {
      const r = container.getBoundingClientRect();
      canvas.width = Math.max(1, (r.width * DPR) | 0);
      canvas.height = Math.max(1, (r.height * DPR) | 0);
      w = canvas.width; h = canvas.height; cx = w / 2; cy = h / 2; scale = Math.min(w, h);
    }
    resize();

    const TAU = Math.PI * 2, rand = (a, b) => a + Math.random() * (b - a);
    const starCount = Math.floor(220 * (scale / 900));
    const stars = Array.from({ length: starCount }, () => ({
      x: rand(0, w), y: rand(0, h), z: rand(0.2, 1), s: rand(0.5, 2.2) * DPR, tw: rand(0.5, 1.5)
    }));

    const rings = [
      { r: .16, w: 2, speed: .06, dash: 38 },
      { r: .25, w: 2.4, speed: -.04, dash: 46 },
      { r: .34, w: 2.8, speed: .03, dash: 54 },
      { r: .45, w: 3, speed: -.02, dash: 64 },
      { r: .58, w: 3.2, speed: .015, dash: 76 },
    ];

    const labels = ['Quantum Core', 'Memory Lattice', 'Cipher Mesh', 'Zeo Kernel', 'PulseChain', 'AuraThread', 'Vault Nexus', 'Signal Gate'];
    const nodes = Array.from({ length: 8 }, (_, i) => ({
      baseR: 0.18 + i * 0.055 + rand(-.01, .01),
      size: (i === 0 ? 4.5 : rand(2.2, 3.6)) * DPR,
      theta: rand(0, TAU),
      speed: (i % 2 === 0 ? 1 : -1) * rand(0.0026, 0.006),
      label: labels[i % labels.length],
      id: i
    }));

    let paused = false, hoverIndex = null;

    function onMove(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * DPR, my = (e.clientY - rect.top) * DPR;
      let found = null;
      for (let i = 0; i < nodes.length; i++) {
        const n = nodes[i], r = n.baseR * scale * 0.5, x = cx + Math.cos(n.theta) * r, y = cy + Math.sin(n.theta) * r;
        const hit = n.size * 3.5, dx = mx - x, dy = my - y;
        if (dx * dx + dy * dy <= hit * hit) { found = i; break; }
      }
      hoverIndex = found;
    }
    function onClick() { paused = !paused; }
    function onToggle() { paused = !paused; }

    window.addEventListener('resize', resize);
    canvas.addEventListener('mousemove', onMove);
    canvas.addEventListener('click', onClick);
    container.addEventListener('quantum:toggle', onToggle);

    function glowCircle(x, y, r, color) {
      const g = ctx.createRadialGradient(x, y, 0, x, y, r);
      g.addColorStop(0, color); g.addColorStop(.3, color + 'a0'); g.addColorStop(1, '#0000');
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x, y, r, 0, TAU); ctx.fill();
    }
    function drawStars(t) {
      for (const s of stars) {
        const tw = .6 + .4 * Math.sin((t * .0012 + s.x * .01) * s.tw);
        ctx.globalAlpha = .55 * s.z * tw;
        ctx.beginPath(); ctx.arc(s.x, s.y, s.s * s.z, 0, TAU);
        ctx.fillStyle = '#9aa4b7'; ctx.fill();
      } ctx.globalAlpha = 1;
    }
    function drawCore(t) {
      const pulse = 1 + .06 * Math.sin(t * .003), coreR = (scale * .06) * pulse;
      glowCircle(cx, cy, coreR * 3.2, coreColor);
      ctx.beginPath(); ctx.arc(cx, cy, coreR, 0, TAU);
      const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreR);
      g.addColorStop(0, '#fff'); g.addColorStop(1, coreColor);
      ctx.fillStyle = g; ctx.fill();
      ctx.globalAlpha = .35; ctx.strokeStyle = accentColor; ctx.lineWidth = 1 * DPR;
      ctx.beginPath();
      ctx.moveTo(cx - coreR * 2, cy); ctx.lineTo(cx + coreR * 2, cy);
      ctx.moveTo(cx, cy - coreR * 2); ctx.lineTo(cx, cy + coreR * 2);
      ctx.stroke(); ctx.globalAlpha = 1;
    }
    function drawRings(t) {
      ctx.strokeStyle = ringColor; ctx.lineCap = 'round';
      for (const def of rings) {
        const baseR = def.r * scale * 0.5, dash = def.dash * DPR, gap = dash * .8, rot = t * def.speed;
        glowCircle(cx, cy, baseR + 12 * DPR, ringColor + '33');
        ctx.save(); ctx.translate(cx, cy); ctx.rotate(rot); ctx.setLineDash([dash, gap]);
        ctx.lineWidth = def.w * DPR; ctx.beginPath(); ctx.arc(0, 0, baseR, 0, TAU); ctx.stroke(); ctx.restore();
      }
    }
    function drawNodes() {
      for (let i = 0; i < nodes.length; i++) {
        const n = nodes[i]; if (!paused) n.theta += n.speed;
        const r = n.baseR * scale * 0.5, x = cx + Math.cos(n.theta) * r, y = cy + Math.sin(n.theta) * r;
        glowCircle(x, y, n.size * 6, nodeColor + (i === hoverIndex ? 'ff' : '88'));
        ctx.beginPath(); ctx.arc(x, y, n.size * (i === hoverIndex ? 1.5 : 1), 0, TAU);
        const g = ctx.createRadialGradient(x, y, 0, x, y, n.size * 1.4);
        g.addColorStop(0, '#fff'); g.addColorStop(1, nodeColor); ctx.fillStyle = g; ctx.fill();
        ctx.globalAlpha = .25; ctx.strokeStyle = accentColor; ctx.lineWidth = 1 * DPR;
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(x, y); ctx.stroke(); ctx.globalAlpha = 1;

        if (i === hoverIndex) {
          const label = n.label, pad = 6 * DPR, bx = x + 10 * DPR, by = y - 10 * DPR;
          ctx.font = `${12 * DPR}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
          const textW = ctx.measureText(label).width, bw = textW + pad * 2, bh = 22 * DPR + pad * 2, rx = 6 * DPR;
          ctx.beginPath();
          const r2 = Math.min(rx, bw / 2, bh / 2);
          ctx.moveTo(bx - pad + r2, by - 14 * DPR - pad);
          ctx.lineTo(bx - pad + bw - r2, by - 14 * DPR - pad);
          ctx.quadraticCurveTo(bx - pad + bw, by - 14 * DPR - pad, bx - pad + bw, by - 14 * DPR - pad + r2);
          ctx.lineTo(bx - pad + bw, by - 14 * DPR - pad + bh - r2);
          ctx.quadraticCurveTo(bx - pad + bw, by - 14 * DPR - pad + bh, bx - pad + bw - r2, by - 14 * DPR - pad + bh);
          ctx.lineTo(bx - pad + r2, by - 14 * DPR - pad + bh);
          ctx.quadraticCurveTo(bx - pad, by - 14 * DPR - pad + bh, bx - pad, by - 14 * DPR - pad + bh - r2);
          ctx.lineTo(bx - pad, by - 14 * DPR - pad + r2);
          ctx.quadraticCurveTo(bx - pad, by - 14 * DPR - pad, bx - pad + r2, by - 14 * DPR - pad);
          ctx.fillStyle = 'rgba(15,18,24,.9)'; ctx.fill();
          ctx.globalAlpha = .6; ctx.strokeStyle = accentColor; ctx.lineWidth = 1 * DPR; ctx.stroke(); ctx.globalAlpha = 1;
          ctx.fillStyle = accentColor; ctx.fillText(label, bx, by + 6 * DPR);
        }
      }
    }

    let raf = 0;
    function loop(t) {
      raf = requestAnimationFrame(loop);
      ctx.fillStyle = background; ctx.fillRect(0, 0, canvas.width, canvas.height);
      drawStars(t); drawRings(t); drawCore(t); drawNodes();
    }
    loop(performance.now());

    // optional cleanup handle
    container.__quantumSimDestroy = () => {
      cancelAnimationFrame(raf);
      window.removeEventListener('resize', resize);
      canvas.removeEventListener('mousemove', onMove);
      canvas.removeEventListener('click', onClick);
      container.removeEventListener('quantum:toggle', onToggle);
    };
  }

  // expose & autoâ€‘boot
  window.renderQuantumSimulation = renderQuantumSimulation;
  window.addEventListener('DOMContentLoaded', () => {
    const c = document.getElementById('quantum-sim');
    if (c && !c.__mounted) { renderQuantumSimulation(c); c.__mounted = true; }
  });
})();
